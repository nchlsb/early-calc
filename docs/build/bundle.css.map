{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\..\\App.svelte"
  ],
  "sourcesContent": [
    "<script lang=\"ts\">import { result, tex } from './expression';\r\n;\r\nimport { endSwitch, maxBy, minBy, orElse, range, sumBy, just, nothing } from \"./helpers\";\r\nimport * as katex from \"katex\";\r\nimport { each, onMount } from 'svelte/internal';\r\n// variables of graph \r\nconst DEFAULT_BOUND_MAGNITUDE = 10;\r\nconst xMaxBound = DEFAULT_BOUND_MAGNITUDE;\r\nconst xMinBound = -DEFAULT_BOUND_MAGNITUDE;\r\nconst yMaxBound = DEFAULT_BOUND_MAGNITUDE;\r\nconst yMinBound = -DEFAULT_BOUND_MAGNITUDE;\r\nlet integralUpperBound = DEFAULT_BOUND_MAGNITUDE;\r\nlet integralLowerBound = -DEFAULT_BOUND_MAGNITUDE;\r\nlet dx = 1;\r\nlet f;\r\n$: f = functions[selectedIndex].implementation;\r\nlet numberOfPoints = 100;\r\n// -10 -> 5\r\n// offset => 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\r\n// lowerBound + offset\r\n// -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5\r\nlet points;\r\n$: points = [...range(numberOfPoints).map(n => {\r\n        const x = xMinBound + (n * ((xMaxBound - xMinBound) / numberOfPoints));\r\n        return { x: x, y: f(x) };\r\n    }), { x: xMaxBound, y: f(xMaxBound) }];\r\nlet numberRectangles;\r\n$: numberRectangles = (integralUpperBound - integralLowerBound) / dx;\r\nlet riemannRectangles;\r\n$: riemannRectangles = range(numberRectangles).map(n => {\r\n    const x = integralLowerBound + (n * (integralUpperBound - integralLowerBound) / numberRectangles);\r\n    const y = f(x);\r\n    // SVG can't process negative height \r\n    return {\r\n        height: Math.abs(y),\r\n        width: dx,\r\n        lowerLeftCorner: { x: x, y: (y > 0) ? 0 : y }\r\n    };\r\n});\r\nconst functions = [\r\n    { id: 'sine', implementation: (x) => Math.sin(x), representation: 'f(x) = \\\\sin(x)' },\r\n    { id: 'const', implementation: (x) => 1, representation: 'f(x) = 1' },\r\n    { id: 'linear', implementation: (x) => x, representation: 'f(x) = x' },\r\n    { id: 'quadratic', implementation: (x) => x * x, representation: 'f(x) = x^2' },\r\n    { id: 'exponential', implementation: (x) => Math.exp(x), representation: 'f(x) = e^x' },\r\n    { id: 'cubic', implementation: (x) => (x - 1) * (x) * (x + 1), representation: 'f(x) = (x - 1)(x)(x + 1)' },\r\n    { id: 'shlub', implementation: (x) => Math.abs(Math.sin(x)), representation: 'f(x) = a(x)' }\r\n];\r\nonMount(() => {\r\n    for (let f of functions) {\r\n        katex.render(f.representation, document.getElementById(`${f.id}`), { output: 'mathml' });\r\n    }\r\n});\r\n/*\r\n\r\n    Done list (for next push)\r\n\r\n        1. (X)Change the consts at the bottom\r\n        3. (X)Add automatically-updating LaTeX equations\r\n\r\n\r\n    Todo list\r\n\r\n        -. (x)2-3 example functions in drop down\r\n            - sine\r\n            - linear\r\n            - const\r\n            - quadratic\r\n            - y = (x - 1)(x)(x + 1)\r\n            - y = e^x\r\n        2. (x)Bounderies should be aligned on the axes or use scroll to zoom\r\n        4. ( )Desktop and mobile friendliness\r\n\r\n\r\n\r\n                5. ( )Negative areas and colors\r\n              Especially when the lower bound is greater than the upper bound\r\n        6. ( )Add testing\r\n              Property based test: symbolic integration and riemann sum give similar results\r\n        8. ( )Automatically determine Y upper and lower bounds via min and max f(x) value\r\n\r\n        10.( ) Highlight over or under estimations as differnt color\r\n        11.( ) make curve smoother\r\n\r\n\r\n        -. ( ) Estimation style drop down\r\n                below\r\n                above\r\n                trapezoid\r\n                both above and below to compare\r\n        9. ( )Dragging uppwer and lower bounds on graph\r\n        7. ( )Custom user equations\r\n*/\r\n// function render(expression: IncompleteExpression): string {\r\n// \tswitch (expression.kind) {\r\n// \t\tcase 'Plus': return `(${render(expression.left)} + ${render(expression.right)})`\r\n// \t\tcase '1': return '1'\r\n// \t\tcase 'Active': return '□'\r\n// \t\tcase 'Inactive': return '■'\r\n// \t} endSwitch(expression)\r\n// }\r\n// let expression: IncompleteExpression = {kind: 'Active'}\r\nlet scoops;\r\nlet selectedIndex = 0;\r\n</script>\r\n\r\n<main>\r\n\t{#each functions as f, index}\r\n\t\t<button class={index === selectedIndex ? 'highlighted' : ''} on:click={_ => selectedIndex = index}><span id={f.id}>{f.representation}</span></button>\r\n\t{/each}\r\n\r\n\t<input id=\"rectangle-width\" type=\"range\" min=\"0.01\" step=\"0.01\" max={xMaxBound - xMinBound} bind:value={dx}>\r\n\t<label for=\"rectangle-width\">Rectangle Width {dx}</label>\r\n\r\n\t<input class=\"bound-range\" type=\"range\" min={xMinBound} max={xMaxBound} step=\".01\" bind:value={integralLowerBound}>\r\n\t<input class=\"bound-range\" type=\"range\" min={xMinBound} max={xMaxBound} step=\".01\" bind:value={integralUpperBound}>\r\n\r\n\t<svg class=\"cartesian\" viewBox=\"{xMinBound} {yMinBound} {(xMaxBound - xMinBound)} {(yMaxBound - yMinBound)}\">\t\t<g>\r\n\t\t\t<!-- x and y axis -->\r\n\t\t\t<line stroke=\"black\" fill=\"none\" x1={xMinBound} y1=\"0\" x2={xMaxBound} y2=\"0\" />\r\n\t\t\t<line stroke=\"black\" fill=\"none\" x1=\"0\" y1={yMinBound} x2=\"0\" y2={yMaxBound} />\r\n\r\n\t\t\t<!-- bounds of intergral -->\r\n\t\t\t<line stroke=\"black\" stroke-dasharray=\"2,2\" fill=\"none\" x1={integralLowerBound} y1={yMinBound} x2={integralLowerBound} y2={yMaxBound} />\r\n\t\t\t<line stroke=\"black\" stroke-dasharray=\"2,2\" fill=\"none\" x1={integralUpperBound} y1={yMinBound} x2={integralUpperBound} y2={yMaxBound} />\r\n\r\n\t\t\t<!-- rectangles -->\r\n\t\t\t{#each riemannRectangles as rectangle}\r\n\t\t\t\t\t<rect\r\n\t\t\t\t\t\tclass=\"riemann-rectangle\"\r\n\t\t\t\t\t\tx={rectangle.lowerLeftCorner.x}\r\n\t\t\t\t\t\ty={rectangle.lowerLeftCorner.y}\r\n\t\t\t\t\t\twidth={rectangle.width}\r\n\t\t\t\t\t\theight={rectangle.height}\r\n\t\t\t\t\t/>\r\n\t\t\t{/each}\r\n\r\n\t\t\t<!-- graph of function -->\r\n\t\t\t<polyline stroke=\"black\" fill=\"none\" points={points.map(point => `${point.x},${point.y}`).join(' ')} />\r\n\r\n\t\t</g>\r\n\t</svg>\r\n</main>\r\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css\" integrity=\"sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X\" crossorigin=\"anonymous\">\r\n<style>\r\n\t.riemann-rectangle {\r\n\t\tfill: gray;\r\n\t\tstroke: black;\r\n\t\tstroke-width: 1;\r\n\t}\r\n\r\n\tline, rect, polyline {\r\n\t\tstroke-width: 1px;\r\n\t\tvector-effect: non-scaling-stroke;\r\n\t}\r\n\r\n\t@media (min-width: 640px) {\r\n\t\tmain {\r\n\t\t\tmax-width: none;\r\n\t\t}\r\n\t}\r\n\r\n\tinput[type=\"range\"], svg.cartesian {\r\n\t\twidth: min(65vh, 100%);\r\n\t\tdisplay: block;\r\n\t}\r\n\r\n\t/* Flip the vertical axis in <g> to emulate cartesian. */\r\n\tsvg.cartesian > g {\r\n\t\ttransform: scaleY(-1);\r\n\t}\r\n\r\n\t/* Re-flip all <text> element descendants to their original side up. */\r\n\tsvg.cartesian > g text {\r\n\t\ttransform: scaleY(-1);\r\n\t}\r\n\r\n\t.highlighted {\r\n\t\tbackground-color: limegreen;\r\n\t}\r\n</style>"
  ],
  "names": [],
  "mappings": "AAiJC,kBAAkB,8BAAC,CAAC,AACnB,IAAI,CAAE,IAAI,CACV,MAAM,CAAE,KAAK,CACb,YAAY,CAAE,CAAC,AAChB,CAAC,AAED,kCAAI,CAAE,kCAAI,CAAE,QAAQ,8BAAC,CAAC,AACrB,YAAY,CAAE,GAAG,CACjB,aAAa,CAAE,kBAAkB,AAClC,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,IAAI,8BAAC,CAAC,AACL,SAAS,CAAE,IAAI,AAChB,CAAC,AACF,CAAC,AAED,KAAK,CAAC,IAAI,CAAC,OAAO,+BAAC,CAAE,GAAG,UAAU,8BAAC,CAAC,AACnC,KAAK,CAAE,IAAI,IAAI,CAAC,CAAC,IAAI,CAAC,CACtB,OAAO,CAAE,KAAK,AACf,CAAC,AAGD,GAAG,yBAAU,CAAG,CAAC,eAAC,CAAC,AAClB,SAAS,CAAE,OAAO,EAAE,CAAC,AACtB,CAAC,AAOD,YAAY,8BAAC,CAAC,AACb,gBAAgB,CAAE,SAAS,AAC5B,CAAC"
}